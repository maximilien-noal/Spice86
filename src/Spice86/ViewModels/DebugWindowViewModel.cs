namespace Spice86.ViewModels;

using Avalonia.Collections;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;

using Spice86.Core.Emulator.VM;
using Spice86.ViewModels.Messages;
using Spice86.ViewModels.Services;

public partial class DebugWindowViewModel : ViewModelBase,
    IRecipient<AddViewModelMessage<DisassemblyViewModel>>, IRecipient<AddViewModelMessage<MemoryViewModel>>,
    IRecipient<RemoveViewModelMessage<DisassemblyViewModel>>, IRecipient<RemoveViewModelMessage<MemoryViewModel>> {

    private readonly IMessenger _messenger;
    private readonly IUIDispatcher _uiDispatcher;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ContinueCommand))]
    private bool _isPaused;

    [ObservableProperty]
    private AvaloniaList<MemoryViewModel> _memoryViewModels = new();

    [ObservableProperty]
    private AvaloniaList<DisassemblyViewModel> _disassemblyViewModels = new();

    /// <summary>
    /// Gets the collection of debugger plugins that appear as tabs.
    /// This allows easy extension of the debugger with new tab types.
    /// </summary>
    [ObservableProperty]
    private AvaloniaList<IDebuggerPlugin> _plugins = new();

    [ObservableProperty]
    private StatusMessageViewModel? _statusMessageViewModel;

    private readonly IPauseHandler _pauseHandler;

    public DebugWindowViewModel(IMessenger messenger, IUIDispatcher uiDispatcher,
        IPauseHandler pauseHandler, IList<IDebuggerPlugin> plugins) {
        messenger.Register<AddViewModelMessage<DisassemblyViewModel>>(this);
        messenger.Register<AddViewModelMessage<MemoryViewModel>>(this);
        messenger.Register<RemoveViewModelMessage<DisassemblyViewModel>>(this);
        messenger.Register<RemoveViewModelMessage<MemoryViewModel>>(this);
        _messenger = messenger;
        _uiDispatcher = uiDispatcher;
        _pauseHandler = pauseHandler;
        IsPaused = pauseHandler.IsPaused;
        pauseHandler.Paused += () => uiDispatcher.Post(() => IsPaused = true);
        pauseHandler.Resumed += () => uiDispatcher.Post(() => IsPaused = false);
        
        Plugins.AddRange(plugins);
        
        // Extract DisassemblyViewModels and MemoryViewModels for backward compatibility
        foreach (var plugin in plugins) {
            if (plugin is DebuggerCollectionPlugin collectionPlugin) {
                foreach (var item in collectionPlugin.Items) {
                    if (item is DisassemblyViewModel disassemblyVm) {
                        DisassemblyViewModels.Add(disassemblyVm);
                    } else if (item is MemoryViewModel memoryVm) {
                        MemoryViewModels.Add(memoryVm);
                    }
                }
            }
        }
    }

    [RelayCommand]
    private void Pause() => _uiDispatcher.Post(() => {
        _pauseHandler.RequestPause("Pause button pressed in debug window");
    });

    [RelayCommand(CanExecute = nameof(IsPaused))]
    private void Continue() => _uiDispatcher.Post(_pauseHandler.Resume);

    public void Receive(AddViewModelMessage<DisassemblyViewModel> message) => DisassemblyViewModels.Add(message.ViewModel);
    public void Receive(AddViewModelMessage<MemoryViewModel> message) => MemoryViewModels.Add(message.ViewModel);
    public void Receive(RemoveViewModelMessage<DisassemblyViewModel> message) => DisassemblyViewModels.Remove(message.ViewModel);
    public void Receive(RemoveViewModelMessage<MemoryViewModel> message) => MemoryViewModels.Remove(message.ViewModel);
}